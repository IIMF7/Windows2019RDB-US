module Elm.Docs.Decode exposing (..)

{-| Generated by elm-json-interop.
-}

import Elm.Docs as A
import Elm.Type.Decode
import Json.Decode as D exposing (Decoder)
import Utils.Json.Decode_ as D_


module_ : Decoder A.Module
module_ =
    D.map6
        (\v1 v2 v3 v4 v5 v6 ->
            { name = v1
            , comment = v2
            , unions = v3
            , aliases = v4
            , values = v5
            , binops = v6
            }
        )
        (D.field "name" D.string)
        (D.field "comment" D.string)
        (D.field "unions" (D.list union))
        (D.field "aliases" (D.list alias))
        (D.field "values" (D.list value))
        (D.field "binops" (D.list binop))


alias : Decoder A.Alias
alias =
    D.map4
        (\v1 v2 v3 v4 ->
            { name = v1
            , comment = v2
            , args = v3
            , tipe = v4
            }
        )
        (D.field "name" D.string)
        (D.field "comment" D.string)
        (D.field "args" (D.list D.string))
        (D.field "tipe" Elm.Type.Decode.type_)


union : Decoder A.Union
union =
    D.map4
        (\v1 v2 v3 v4 ->
            { name = v1
            , comment = v2
            , args = v3
            , tags = v4
            }
        )
        (D.field "name" D.string)
        (D.field "comment" D.string)
        (D.field "args" (D.list D.string))
        (D.field "tags" (D.list (D_.tuple D.string (D.list Elm.Type.Decode.type_))))


value : Decoder A.Value
value =
    D.map3
        (\v1 v2 v3 ->
            { name = v1
            , comment = v2
            , tipe = v3
            }
        )
        (D.field "name" D.string)
        (D.field "comment" D.string)
        (D.field "tipe" Elm.Type.Decode.type_)


binop : Decoder A.Binop
binop =
    D.map5
        (\v1 v2 v3 v4 v5 ->
            { name = v1
            , comment = v2
            , tipe = v3
            , associativity = v4
            , precedence = v5
            }
        )
        (D.field "name" D.string)
        (D.field "comment" D.string)
        (D.field "tipe" Elm.Type.Decode.type_)
        (D.field "associativity" associativity)
        (D.field "precedence" D.int)


associativity : Decoder A.Associativity
associativity =
    D.field "_" D.int
        |> D.andThen
            (\i___ ->
                case i___ of
                    0 ->
                        D.succeed A.Left

                    1 ->
                        D.succeed A.None

                    2 ->
                        D.succeed A.Right

                    _ ->
                        D.fail ("I can't decode \"Associativity\", unknown variant with index " ++ String.fromInt i___ ++ ".")
            )


block : Decoder A.Block
block =
    D.field "_" D.int
        |> D.andThen
            (\i___ ->
                case i___ of
                    0 ->
                        D.map A.MarkdownBlock (D.field "a" D.string)

                    1 ->
                        D.map A.UnionBlock (D.field "a" union)

                    2 ->
                        D.map A.AliasBlock (D.field "a" alias)

                    3 ->
                        D.map A.ValueBlock (D.field "a" value)

                    4 ->
                        D.map A.BinopBlock (D.field "a" binop)

                    5 ->
                        D.map A.UnknownBlock (D.field "a" D.string)

                    _ ->
                        D.fail ("I can't decode \"Block\", unknown variant with index " ++ String.fromInt i___ ++ ".")
            )
